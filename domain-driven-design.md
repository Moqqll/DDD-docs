# DOMAIN-DRIVEN DESIGN

## 前言

### 设计过程与开发过程

敏捷开发，如极限编程，它将相当大的精力投入到促进沟通和提高项目快速变更能力的工作中，具有这种反应能力后，开发人员就可以在项目的任何阶段只利用 “最简单而管用的方案”，然后不断进行重构，一步一步做出小的设计改进，最终得到满足客户真正需要的设计。

但是，以上有关敏捷过程的思想可能会被误解，每个人对 ”最简单“ 都有不同的定义。持续重构其实是一系列小规模的重新设计，没有严格设计原则（设计知识）的开发人员将会创建出难以理解或修改的代码，这恰好与敏捷的精神相悖。而且，虽然对意外需求的担心常常导致过渡设计，但试图避免过度设计又可能走向另一个极端---不敢做任何深入地设计思考。

### 领域驱动团队

尽管开发人员个人能够从理解领域驱动设计中学到有价值的设计技术和观点，但最大的好处却是来自团队共同应用领域驱动设计方法，并且将领域模型作为项目沟通的核心，将敏捷开发（遵循严格设计原则的持续设计重构）作为项目编码的最佳实践。

这样，团队成员就有了一种公共语言，可以用来进行更充分的沟通，并确保围绕软件来进行沟通，他们将创建出一个与模型步调一致的清晰的实现，从而为应用程序的开发提供帮助。

所有人都了解不同团队的设计工作之间的联系，而且他们会一致将注意力集中在那些最组织最有价值、最与众不同的特性的开发商上。

## 第一部分

### 第1章 消化知识

#### 1.1 有效建模的要素

* 模型和实现的绑定
* 建立了一种基于模型的语言
* 开发一个蕴含丰富知识的模型
* 提炼模型
* 头脑风暴和实验

#### 1.2 知识消化

有些项目使用了迭代过程，但由于没有对知识进行抽象而无法建立起知识体系。开发人员听专家描述某项所需的特性，然后开始构建它。他们把结果展示给专家，并询问接下来做什么。如果程序员愿意进行重构，则能够保持软件足够简洁，以便继续拓展它；但如果程序员对领域不感兴趣，则他们只会了解程序应该执行的过程，而不去了解它背后的原理。虽然这样也能开发出可用的软件，但项目永远也不会从原来特性中自然地拓展出强大的新特性。

在团队所有成员一起消化理解模型的过程中，他们之间的交互也会发生变化。领域模型的不断精华迫使开发人员学习重要的业务原理，而不是机械地进行功能的开。领域专家被迫提炼自己知道的重要知识的过程往往也是完善其自身理解的过程，而且他们会渐渐理解软件项目所必需的概念严谨性。

模型在不断改进的同时，也成为组织项目信息流的工具。模型聚焦与需求分析，它与编程、设计紧密交互，它通过良性循环加深团队成员对领域的理解，使他们更透彻地理解模型，并对其进一步精化。

模型永远都不会是完美的，因为它是一个不断演进完善的过程。模型对理解领域必须是切实可用的，它们必须非常精确，以便使应用程序易于理解和实现。

#### 1.3 持续学习

看起来没有什么技术难度的领域很可能是一种错局---我们并没有意识到不知道的东西究竟有多少。这种无知往往会导致我们做出错误的假设。

同时，所有项目都会丢失知识。已经学到了一些知识的人可能干别的事情去了，团队可能由于重组而被拆散，这导致只是又重新分散开，被外包出去的关键子系统可能只交回了代码，而不会将知识传递回来，而且使用典型的设计方法时，代码和文档不会以一种有用的形式表示出这些来之不易的知识，因此一旦由于某种原因人们没有口头传递知识，那么知识就丢失了。

#### 1.4 知识丰富的设计

通过模型获得的只是远远不只是 “发现名词”，业务活动和规则如果所涉及的实体一样，都是领域的核心。当我们建模不再局限于寻找实体和值对象时，我们才能够充分吸取知识，因为业务规则之间可能会存在不一致。

#### 1.5 深层模型

有用的模型很少停留在表面。随着对领域和应用程序需求的理解逐步加深，我们往往会丢弃那些最初看起来很重要的表面元素，或者切换它们的角度，这时，一些开始时不可能发现的巧妙抽象就会渐渐浮出水面，而它们恰恰切中问题的要害。

以书中集装箱航运项目为例，在这个项目中，由于航运从预订货运开始，因此我们开发了一个能够描述货物和运货航线等事物的模型这是必要且有用的，但领域专家却不买账，他们有自己的考虑业务的方式，这种方式是我们没有考虑到的。

在经过几个月的知识消化后，我们知道货物的处理主要是由转包商或公司中的操作人原完成的，这包括实际的装货、运货和卸货。航运专家的观点是，各部分之间存在一系列的责任传递，法律责任和执行责任的传递由一个过程控制---从托运人传递到某个本地运输商，再从这个运输商传递到另一家运输商，最后到达收货人。

对航运业务有了更深刻的认识后，我们并没有删除 Itinerary（航线）对象，但模型发生了巨大改变，我们对航运业务的认识从 ”集装箱在各个地点之间的运输“ 转变为 ”运货责任在各个实体之间的传递“，处理这些责任传递的特性不再是一些附属于装货作业的次要特性，而是由一个独立的模型来提供支持，这个模型正是在理解了作业与责任之间的重要关系之后开发出来的。

**知识消化是一种探索，它永无止境**

### 第2章 交流与语言的使用

![image-20211002221232646](domain-driven-design.assets/image-20211002221232646.png)

```
用户：那么，当更改清关（customs clearance）地点时，需要重新制定整个路线计划啰？
开发人员：是的。我们将从货运表（shipment table）中删除所有与该货物id相关联的行，然后将出发地、目的地和新的清关地点传递给RoutingService，它会重新填充货运表。Cargo中必须设置一个布尔值，用于指示货运表中是否有数据。
用户：删除行？好，就按你说的做。但是，如果先前根本没有指定清关地点，也需要这么做吗？
开发人员：是的，无论何时更改了出发地、目的地或清关地点（或者第一次输入），都将检查是否已经有货运数据，如果有，则删除它们，然后由RoutingService重新生成数据。
用户：当然，如果原有的清关数据彭票是正确的，我们就不需要这样做了。
开发人员：哦，没问题，但让RoutingService每次重新加载或卸载数据会更容易些。
用户：是的，但为新航线制定所有的支持计划的工作量很大，因此，除了非改不可，我们一般不想更改航线。
开发人员：哦，好的，当第一次输入清关地点时，我们需要查询表格，找到以前的清关地点，然后与新清关地点进行比较，从而判断是否需要重做。
用户：这个处理不需要考虑出发地和目的地，因为航线在此总要变更。
开发人员：好的，我明白了。
```

　![image-20211002222100720](domain-driven-design.assets/image-20211002222100720.png)

```
用户：那么，当更改清关地点时，需要重新制定整个路线计划啰。
开发人员：是的，当更改Route Specification（路线说明）的任意属性时，都将删除原有的Itinerary（航线），并要求RoutingService（路线服务）基于新的RouteSpecification生成一个新的Itinerary。
用户：如果先前更没有指定清关地点，也需要这么做吗？
开发人员：是的，无论何时更改了Route Specification的任何属性，都将重新生成Itinerary，这也包括第一次输入某些属性。
用户：当然，如果原有的清关数据碰巧是正确的，我们就不需要这样做了。
开发人员：哦，没问题，但让RoutingService每次重新生成一个itinerary会更容易些。
用户：是的，但为新航线制定所有的支持计划的工作量很大，因此，除非非改不可，我们一般不想更改路线。
开发人员：哦，那么需要在RouteSpecification添加一些功能。这样，当更改其中的属性时，查看itinerary是否仍满足specification，如果不满足，则需要由RoutingService重新生成itinerary。
用户：这一点不必考虑出发点和目的地，因为itinerary在此总是要变化的。
开发人员：好的，但每次只做比较就简单多了。只有当不满足RouteSpecification时，才重新生成itinerary。
```

第二段对话表达了领域专家的更多意图，在这两段对话中，用户都使用了 itinerary 航线 这个词，但在第二段中它是一个对象，这使得双方可以更准确、具体地进行讨论。他们明确讨论了 route specification，而不是每次都通过属性和过程来描述它。

这两段对话都有意使用了相似的结构，实际上，第一段对话显得更啰嗦，对话双方需要不断对应用程序的特性和表达不清的地方进行解释，第二段对话使用了基于领域模型的术语，因此讨论更简洁。